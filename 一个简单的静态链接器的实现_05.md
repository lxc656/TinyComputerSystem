本篇Blog完成静态链接器的引用重定位的工作的实现，对于“什么是引用重定位？”可以用如下的例子来说明

如果我们在一个C程序里有如下的代码

```c
extern int sum(int a , int b);
void main()
{
  sum(a,b);
}
```

`sum`函数的定义并不在这个程序文件中，而且在这个程序的ELF文件的符号表中，`sum`符号对应的三元组应该是(global,notype,undef)，我们在执行到调用`sum`函数的那行代码时，需要跳转到外部的文件去执行，引用重定位要做的，就是让我们跳转到正确的地址去执行外部函数的指令

我们假定上面这段程序所在的文件叫`a.c`，`a.c`编译生成的ELF文件叫`a.o`，`a.c`中引用外部定义的`sum`函数的那行代码位于`a.o`的.text节，并且由于在编译`a.c`这单个文件时，编译器也不知道外部文件的信息，因此引用`sum`函数的那行代码会被编译成`call 0x00...0`，由于编译器不知道外部的`sum`函数在runtime时的地址，所以就先将`call`后的地址写成64位的0（对于64位系统来说是这样的，因为地址是64位的），将来能够定位`sum`函数的runtime地址之后，再将这一堆0改成正确的runtime地址，为了完成这个重定位的工作（引用重定位顾名思义说的就是这个），`a.o`这个ELF文件里还有一个section叫做 .rel.text section，其中rel的意思便是relocate，即重定位，后面跟着.text，便是说要帮助.text节中出现的外部引用完成重定位（因为在.data节中也有可能出现外部引用，并且仅这两个节有可能出现外部引用，所以被链接前的ELF文件里都有.rel.text节和.rel.data节），.rel.text节有很多表项，每个表项中都有如下信息：在.text中发生外部引用的代码在.text节中的offset，被引用的符号在`a.o`的符号表中的index，外部引用的Type，以及addend项（最后这两个会在后面介绍，现在不需要知道是什么意思）

除了引用外部的函数，还有可能引用外部的数据

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsduu970jj30xg0fgwfr.jpg" style="zoom:40%;" />

上图的程序里，不仅引用了外部的`undef_func`函数，还引用的外部的`undef_array`数组，我们接下来分析这段程序被编译后生成的汇编指令

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsdxt0sdrj30uu0cg3zg.jpg" style="zoom:50%;" />

上图中被黄色荧光标注的地方是调用外部函数的指令，可以看到，和前面介绍的一样，用一个64位的0去暂时替代真正的runtime地址，接下来分析引用外部数组的指令

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwse3azpqqj30vm0cojsc.jpg" style="zoom:50%;" />

同样也是只需关注黄色荧光标注的部分，被标注处的前面的`c7 05`是`movl`指令的机器码，由于编译器不知道外部的`undef_array`数组的runtime地址，因此也是在代码中用一堆0来代替，不过可以看到，只有32位的0，而且结合汇编指令可以看到，此处对`undef_array[0]`的寻址是`%rip`寄存器相对寻址，后面对`undef_array[1]`的寻址也是如此，而且还要注意，在对`undef_array[0]`进行寻址时，`%rip`的值是0x15而非0xe（这是因为真实的处理器在取完一条指令之后就会更新pc，而不是等待指令被执行完才更新pc，和我们写的虚拟机的逻辑在此处不一样）

由于是相对寻址，所以说我们需要把前面说的32位的0在将来的重定位过程中改写为`undef_array[0]`的runtime地址相对于`%rip`所指向的地址的相对偏移量

接下来我们看一下Linux系统中.rel.text节的每个表项的数据结构的实现，在`/usr/include/elf.h`中有声明

![](https://tva1.sinaimg.cn/large/008i3skNly1gwseim5dvpj31ae0bqgmm.jpg)

可以看到，`r_offset`就是前面说的“在.text中发生外部引用的代码在.text节中的offset”，`r_info`有64位，前32位用于记录前面说的“外部引用的Type”，引用外部数据的Type包括pc相对寻址（就是我们刚才对`undef_array[0]`进行寻址的方法），还包括绝对地址寻址（就是在重定位时填入runtime的绝对地址），对于引用外部函数的情况，进行寻址的办法有GOT,PLT，会在后面介绍。`r_info`的后32位是前面说的“被引用的符号在当前ELF文件的符号表中的index”

针对我们实现的简单的静态链接器来说，设计的数据结构则有所不同

我们的`r_offset`就不应该是以字节为单位的偏移量了，针对.txt文本来说，设置成以行和列为单位的偏移量更合适，以这个行和列的偏移在`elf_t`数据结构的`buffer`里去定位.text节中发生外部引用的代码中的那一堆被暂时填充的0

接下来介绍实现引用重定位的具体方法，如果源文件使用绝对地址寻址进行外部引用，进行外部引用的这段代码会在符号解析后与其他源文件进行section合并，这时如果我们直接拿.rel.text中的表项的offset值在新的目标文件的.text节中去定位这段代码，因为这个值是在源elf文件的.text节中的offset，所以会出现偏差，如下图所示

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsmms3cw7j31bz0u0q8n.jpg" style="zoom:150%;" />

正确的在目标文件中定位的方式如下图

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsne0x393j31fb0u0444.jpg" style="zoom:150%;" />

接下来开始代码实现，其他的pc相对引用时的引用重定位和PLT引用重定位会在代码实现中介绍

如下是.rel.text节以及.rel.data节中的每个表项的数据结构

```c
typedef enum
{
    R_X86_64_32,
    R_X86_64_PC32,
    R_X86_64_PLT32,
} reltype_t;

// relocation entry type
typedef struct
{
    /*  this is what's different in our implementation. instead of byte offset, 
        we use line index + char offset to locate the symbol */
    uint64_t    r_row;      // line index of the symbol in buffer section
                            // for .rel.text, that's the line index in .text section
                            // for .rel.data, that's the line index in .data section
    uint64_t    r_col;      // char offset in the buffer line
    reltype_t   type;       // relocation type
    uint32_t    sym;        // symbol table index
    int64_t     r_addend;   // constant part of relocation expression
} rl_entry_t;
```

还有在之前的`elf_t`数据结构中加入.rel.text和.rel.data这两个section（这两个section本质上就是两个表）

```c
typedef struct
{
    char buffer[MAX_ELF_FILE_LENGTH][MAX_ELF_FILE_WIDTH];
    uint64_t line_count;

    uint64_t sht_count;
    sh_entry_t *sht;

    uint64_t symt_count;
    st_entry_t *symt;

    uint64_t reltext_count;
    rl_entry_t *reltext;

    uint64_t reldata_count;
    rl_entry_t *reldata;
} elf_t;
```

相应的，在`parse_elf.c`中也会加入专门来parse出这两个表的操作(详情可参考代码https://github.com/yangminz/bcst_csapp/blob/main/src/linker/parseElf.c)

此外还有一点，如果在一个ELF文件内引用了在这个文件内部定义的符号，也需要进行引用重定位，即在.rel.text节或.rel.data节里有对应的表项，因为进行section merge之后这些被引用的符号的runtime地址对于编译器来说是完全不知道的

完成引用重定位所需的函数如下

```c
/* ------------------------------------ */
/* Relocation                           */
/* ------------------------------------ */
static void relocation_processing(elf_t **srcs, int num_srcs, elf_t *dst,
    smap_t *smap_table, int *smap_count);

static void R_X86_64_32_handler(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced);
static void R_X86_64_PC32_handler(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced);
static void R_X86_64_PLT32_handler(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced);

typedef void (*rela_handler_t)(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced);

static rela_handler_t handler_table[3] = {
    &R_X86_64_32_handler,       // 0
    &R_X86_64_PC32_handler,     // 1
    // linux commit b21ebf2: x86: Treat R_X86_64_PLT32 as R_X86_64_PC32
    &R_X86_64_PC32_handler,     // 2
};
```

和之前虚拟机的设计思路一样，采用了handler_table，可以根据所提供的枚举值直接执行对应的处理函数

接下来分析`relocation_processing`函数的实现

我们首先得到目标文件的.text节或.data节在目标文件的SHT中的表项

![](https://tva1.sinaimg.cn/large/008i3skNly1gwtod09o0bj30u80h6acb.jpg)

之后开始遍历所有的源文件，对于当前被遍历到的源文件，遍历其.rel.text节的所有表项，之后拿到当前被遍历的表项的r_offset，在当前源文件的.text节的所有符号中进行判断筛选，依据其是否满足st_value<=r_offset<=st_value+st_size，判断出是不是在这个符号对应的函数内发生了此时被遍历到的.rel.text节的表项所描述的外部引用

![](https://tva1.sinaimg.cn/large/008i3skNly1gwtor34g4cj30v60o877d.jpg)

之后在`smap_table`里找到`smap_t.src`指向“在其内部发生外部引用的函数”对应的符号的`smap_t`变量，并通过它的`smap_t.dst`找到目标文件中对应的符号

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtoz93seoj30r00bs3zx.jpg" style="zoom:50%;" />

之后，我们根据.rel.text节当前的表项可以得知在源ELF文件中引用的外部符号的名字，我们便去`smap_table`中遍历，看看`smap_table`有没有符号和这个被引用的符号同名而且其Bind值是global，如果是的话，便得到了被引用的外部符号

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwtp4borhej30vq0lkn02.jpg" style="zoom:50%;" />

之后调用.rel.text的entry中的Type对应的handler去完成引用重定位最后的一步：将目标文件.text节代码中那一堆为0的引用地址改写为真实的runtime地址，传递给handler的参数中，使用了按照前面的示意图中描述的方式计算出的“在目标文件中的发生外部引用处的`r_offset`”，即下面这行计算式：

```c
r->r_row - sym->st_value + eof_referencing->st_value
```

如果重定位的type是绝对地址寻址，那思路就是简单的计算出被引用的符号的runtime地址之后直接overwrite

```c
static void R_X86_64_32_handler(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced)
{
    uint64_t sym_address = get_symbol_runtime_address(dst, sym_referenced);
    char *s = &dst->buffer[sh->sh_offset + row_referencing][col_referencing];
    write_relocation(s, sym_address);
}

static uint64_t get_symbol_runtime_address(elf_t *dst, st_entry_t *sym)
{
    // get the run-time address of symbol
    uint64_t base = 0x00400000;

    uint64_t text_base = base;
    uint64_t rodata_base = base;
    uint64_t data_base = base;

    int inst_size = sizeof(inst_t);
    int data_size = sizeof(uint64_t);

    // must visit in .text, .rodata, .data order
    sh_entry_t *sht = dst->sht;
    for (int i = 0; i < dst->sht_count; ++ i)
    {
        if (strcmp(sht[i].sh_name, ".text") == 0)
        {
            rodata_base = text_base + sht[i].sh_size * inst_size;
            data_base = rodata_base;
        }
        else if (strcmp(sht[i].sh_name, ".rodata") == 0)
        {
            data_base = rodata_base + sht[i].sh_size * data_size;
        }
    }
    
    // check this symbol's section
    if (strcmp(sym->st_shndx, ".text") == 0)
    {
        return text_base + inst_size * sym->st_value;
    }
    else if (strcmp(sym->st_shndx, ".rodata") == 0)
    {
        return rodata_base + data_size * sym->st_value;
    }
    else if (strcmp(sym->st_shndx, ".data") == 0)
    {
        return data_base + data_size * sym->st_value;
    }

    return 0xFFFFFFFFFFFFFFFF;
}

static void write_relocation(char *dst, uint64_t val)
{    
    char temp[20];
    sprintf(temp, "0x%016lx", val);
    for (int i = 0; i < 18; ++ i)
    {
        dst[i] = temp[i];
    }
}
```

对于跑在x86硬件架构上的Linux，type为PLT32和PC32的引用重定位是同一种实现，没有差别，因此我们只需实现PC32，即pc相对寻址情况下的引用重定位

![](https://tva1.sinaimg.cn/large/008i3skNly1gwtugelbv8j30xi0iumzo.jpg)

```c
static void R_X86_64_PC32_handler(elf_t *dst, sh_entry_t *sh,
    int row_referencing, int col_referencing, int addend,
    st_entry_t *sym_referenced)
{
    assert(strcmp(sh->sh_name, ".text") == 0);

    uint64_t sym_address = get_symbol_runtime_address(dst, sym_referenced);
    uint64_t rip_value = 0x00400000 + (row_referencing + 1) * sizeof(inst_t);
    char *s = &dst->buffer[sh->sh_offset + row_referencing][col_referencing];
    write_relocation(s, sym_address - rip_value);
}
```

因为我们的简单链接器十分的mini且特殊，因此在完成pc相对寻址时没有使用.rel.text节的表项里提供的`addend`，`addend`代表引用位置与下一条指令的相对位置关系，上文提到过，发生外部引用的指令被执行时，pc指向的是它后面的指令，`addend`的作用在于计算被引用的符号所在地址相对于`%rip`的offset时需要拿它来做修正

实现的思路基本上都说完了，这个静态链接器的实现到此完结撒花！

感谢https://www.zhihu.com/people/zhao-yang-min这位大佬能在b站上带给我们这么好的课～

Reference:

https://www.bilibili.com/video/BV1GU4y1h7mt?spm_id_from=333.999.0.0

https://github.com/yangminz/bcst_csapp/tree/d2c4f611d0cffb8e029c254a41100be58392577f

https://github.com/yangminz/bcst_csapp/releases