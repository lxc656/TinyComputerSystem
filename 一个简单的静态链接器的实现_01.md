为了便于模拟连接器的工作流程，因此采用了txt文本类型的文件代替ELF文件来进行链接，并设计了一种类似于ELF文件格式的txt文件内容组织形式，其与ELF文件的异同之处如下图

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwluot3ykvj31b70u0jyh.jpg" style="zoom:400%;" />

在.txt格式的txt文件中的组织形式就是下面这样

```shell
count of effective lines

count of section header table lines

begin of section header table(表项格式：sh_name,sh_addr,sh_offset,sh_size)

.text section

.symtab(表项格式：st_name,bind,type,st_shndx,st_value,st_size)
```

相比于ELF文件中的各种表的记录各种信息的表项，我们简单的“仿ELF”文件格式中少了一些用不太上的信息，只保留了关键的信息，但最终实现的静态连接器的逻辑和链接的原理是一样的，由于是自己造轮子diy，所以在这样的txt文件中也可以包含"//"开头的注释，还可以在解析的时候自动忽略空行，这些我们都可以在后续的代码逻辑中实现，.text节由汇编代码来填充，正好我们之前的Blog中实现了解析字符串汇编指令的虚拟机，可以将这个diy的链接器和diy的虚拟机联系起来，因此我们还需对汇编指令稍微处理一下，以便能满足我们之前解析字符串汇编指令时允许的格式，我们diy的ELF版本里SHT的表项中的sh_offset是对应的section所在的行数，sh_size是对应的section占用多少行

我们在一个名为`sum.c`的文件当中声明如下的函数和变量，注释中标记了它们所属的(Bind, Type, Section)三元组

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvjbrbzqj315y0fstaa.jpg" style="zoom:80%;" />

之后在`main.c`中引用它们，同样注释里也标注了符号对应的三元组

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwlvt7wycwj30rq0ce75l.jpg" style="zoom:80%;" />

之后以`gcc -c`将它们分别编译成`sum.o`和`main.o`

然后用sum.o的反汇编代码填装我们的txt文件，如下

```shell
// unsigned long long bias; // global, object, common
// // global, function, text
// unsigned long long sum (unsigned long long *a, unsigned long long n)
// {
//     unsigned long long i, s = 0;
//     for (i = 0; i < n; ++ i)
//     {
//         s += a[i];
//     }
//     return s + bias;
// }

// count of effective lines
28

// count of section header table lines
2

// begin of section header table
// sh_name,sh_addr,sh_offset,sh_size
.text,0x0,4,22
.symtab,0x0,26,2

// .text section
push   %rbp
mov    %rsp,%rbp
mov    %rdi,-0x18(%rbp)
mov    %rsi,-0x20(%rbp)
movq   $0x0,-0x8(%rbp)
movq   $0x0,-0x10(%rbp)
jmp    3d // <sum+0x3d>
mov    -0x10(%rbp),%rax
lea    0x0(,%rax,8),%rdx
mov    -0x18(%rbp),%rax
add    %rdx,%rax
mov    (%rax),%rax
add    %rax,-0x8(%rbp)
addq   $0x1,-0x10(%rbp)
mov    -0x10(%rbp),%rax
cmp    -0x20(%rbp),%rax
jb     1e // <sum+0x1e>
mov    0x0(%rip),%rdx
mov    -0x8(%rbp),%rax
add    %rdx,%rax
pop    %rbp
retq

// .symtab
// st_name,bind,type,st_shndex,st_value,st_size
sum,STB_GLOBAL,STT_FUNCTION,.text,0,22
bias,STB_GLOBAL,STT_OBJECT,COMMON,8,8
```

注：sum函数对应的符号的st_size是它的字符串汇编代码占用的行数

之后我们便开始在我们之前做的简单的虚拟机上实现链接器，首先在headers目录下创建`linker.h`，用来完成对链接器实现的相关定义，首先定义SHT的表项的数据结构

```c
#define MAX_CHAR_SECTION_NAME (32)

typedef struct
{
    char sh_name[MAX_CHAR_SECTION_NAME];
    uint64_t sh_addr;
    uint64_t sh_offset;     // line offset or effective line index
    uint64_t sh_size;
} sh_entry_t;
```

之后是符号表的表项的数据结构

```c
#define MAX_CHAR_SYMBOL_NAME (64)

typedef enum
{
    STB_LOCAL,
    STB_GLOBAL,
    STB_WEAK
} st_bind_t;

typedef enum
{
    STT_NOTYPE,
    STT_OBJECT,
    STT_FUNC
} st_type_t;

typedef struct
{
    char st_name[MAX_CHAR_SECTION_NAME];
    st_bind_t bind;
    st_type_t type;
    char st_shndx[MAX_CHAR_SECTION_NAME];
    uint64_t st_value;      // in-section offset
    uint64_t st_size;       // count of lines of symbol
} st_entry_t;
```

这些数据结构的设计和真正的ELF格式包含的数据相比是删去了一些不大用得上的信息的，正如前面所说，我们实现简单的链接器的目的是彻底搞懂链接的过程和逻辑

我们还需要一个在解析ELF中的字符的时候的缓冲区，通过如下的数据结构来实现

```c
#define MAX_ELF_FILE_LENGTH (64)    // max 64 effective lines
#define MAX_ELF_FILE_WIDTH (128)    // max 128 chars per line

typedef struct
{
    char buffer[MAX_ELF_FILE_LENGTH][MAX_ELF_FILE_WIDTH];
    uint64_t line_count;

    sh_entry_t *sht;
} elf_t;
```

之后开始实行对于ELF文件的读取和无效信息过滤，新建一个`linker`目录，之后在其中创建`parseELF.c`文件用于实现该功能，代码如下：

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>
#include<string.h>
#include<assert.h>
#include<headers/linker.h>
#include<headers/common.h>

int read_elf(const char *filename, uint64_t bufaddr)
{
    // open file and read
    FILE *fp;
    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        debug_printf(DEBUG_LINKER, "unable to open file %s\n", filename);
        exit(1);
    }

    // read text file line by line
    char line[MAX_ELF_FILE_WIDTH];
    int line_counter = 0;

    while (fgets(line, MAX_ELF_FILE_WIDTH, fp) != NULL)
    {
        int len = strlen(line);
        if ((len == 0) || 
            (len >= 1 && (line[0] == '\n' || line[0] == '\r')) ||
            (len >= 2 && (line[0] == '/' && line[1] == '/')))
        {
            continue;
        }

        // check if is empty or white line
        int iswhite = 1;
        for (int i = 0; i < len; ++ i)
        {
            iswhite = iswhite && (line[i] == ' ' || line[i] == '\t' || line[i] == '\r');
        }
        if (iswhite == 1)
        {
            continue;
        }

        // to this line, this line is not white and contains information

        if (line_counter < MAX_ELF_FILE_LENGTH)
        {
            // store this line to buffer[line_counter]
            uint64_t addr = bufaddr + line_counter * MAX_ELF_FILE_WIDTH * sizeof(char);
            char *linebuf = (char *)addr;

            int i = 0;
            while (i < len && i < MAX_ELF_FILE_WIDTH)
            {
                if ((line[i] == '\n') || 
                    (line[i] == '\r') || 
                    ((i + 1 < len) && (i + 1 < MAX_ELF_FILE_WIDTH) && line[i] == '/' && line[i + 1] == '/'))
                {
                    break;
                }
                linebuf[i] = line[i];
                i ++;
            }
            linebuf[i] = '\0';
            line_counter ++;
        }
        else
        {
            debug_printf(DEBUG_LINKER, "elf file %s is too long (>%d)\n", filename, MAX_ELF_FILE_LENGTH);
            fclose(fp);
            exit(1);
        }
    }

    fclose(fp);
    assert(string2uint((char *)bufaddr) == line_counter);
    return line_counter;
}
```

Reference:

https://www.bilibili.com/video/BV1Ji4y1K7uw?spm_id_from=333.999.0.0

https://github.com/yangminz/bcst_csapp/tree/d7f871ced7e796fd75520b2af0cd14b390339cf7/src