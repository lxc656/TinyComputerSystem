在完成了符号解析之后，下一步的工作是多个源文件各自的section合并为目标文件的section，并且填充好目标ELF文件的各种信息，首先填充目标ELF文件的SHT内的信息

`smap_table`数组记录了从源文件到目标文件的所有符号映射关系，而目标文件的各个section的数据也都是由这些符号所对应的数据所构成，因此我们只要遍历一遍`smap_table`内的所有符号，就能确定目标ELF文件的各个section都由哪些符号的数据构成，size是多少，我们实现一个名为`compute_section_header`的函数去完成这个工作，接下来逐步分析具体的代码实现

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwrici9hjmj30qa0naju3.jpg" style="zoom:50%;" />

最开始这段代码就是遍历扫描了`smap_table`里所有的符号，将它们的size累加到它们所在的section的size上，这个循环结束之后就可以确定目标文件各个section的size。因为.bss section是只有程序被加载到内存中执行的时候才会给在它在内存里分配空间的，硬盘里中的ELF文件里没有.给bss节分配的存储空间，在这个函数里我们的最终目的是要计算出各个section在ELF里占据的size，以便进一步得到各个section在目标文件中的offset，然后在目标文件的SHT表项中填入对应的信息，所以说.bss节包含的所有符号的总size的大小对这个过程的结果没有影响，我们的仿ELF格式的txt文件的SHT里也没有.bss节对应的表项，因此就不计算.bss节的size（虽然说真实的链接器会在SHT的.bss节对应的表项里记录.bss节的所有符号的总size，这样才能在程序被载入内存执行时给.bss节中的符号对应的变量分配正确大小的内存空间）

继续分析后面的代码

![](https://tva1.sinaimg.cn/large/008i3skNly1gwriyssb82j313i08qq4z.jpg)

我们通过判断.text节/.rodata节/.data节的size是否非0进而判断它们是否存在从而得出SHT的长度(符号表一定存在，SHT中必定有它对应的表项)，得知了SHT的长度和各个section的size，就可以算出整个ELF的size，于是填入ELF header

继续分析代码

![](https://tva1.sinaimg.cn/large/008i3skNly1gwrkmtknf1j317q05atan.jpg)

根据Linux系统加载可执行程序的规则，可执行文件会被加载到0x400000虚拟地址起始的用户地址空间，这段内存中接连存放着.text节->.rodata节->.data节，因此上面的代码里计算出了它们各自被加载到内存时的虚拟地址，目标文件被执行时，符号表不会被加载到内存，因此它的虚拟地址设置为0，这些都会在后面被写入SHT中对应的表项

之后开始创建目标文件的SHT，我们已经计算出了它的表项数(即前面的SHT的长度)，以此在堆中给它申请内存空间

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwrkx5wwqnj30ne03s0t4.jpg" style="zoom:50%;" />

之后我们去填写SHT的各个表项

首先是.text节对应的表项

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwrl3janjbj30pu0rgwht.jpg" style="zoom:50%;" />

后面的.rodata节，.data节都是同理

最后填写符号表对应的表项

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwrl6jaiq5j30oc0g6q52.jpg" style="zoom:50%;" />

这便完成了对目标文件的SHT，即节头表的创建和填写，并且其实我们也在目标文件的`buffer`里写入了我们此前设计的ELF格式中的SHT以及SHT前面的信息(`buffer`是`elf_t`数据结构的一个成员变量，作为一个二维数组用来存放字符串形式的ELF文件的原始数据，详情参考之前https://zhuanlan.zhihu.com/p/435806310中对`elf_t`数据结构的实现)

接下来要做的就是将源文件的section合并到目标文件的section中，我们使用`merge_section`函数来实现

函数原型如下，继承自`link_elf`函数向外暴露的接口

```c
static void merge_section(elf_t **srcs, int num_srcs, elf_t *dst, smap_t *smap_table, int *smap_count);
```

接下来介绍函数的实现

要合并section，简单的说就是把目标文件的某个section中的所有符号对应的数据从源文件的`buffer`拷贝到目标文件的`buffer`中该section对应的区域，我们可以先通过`smap_table`得到目标文件的各个符号对应的符号表表项，进而判断出它们都在其所在的源文件的哪个section里，之后通过所在的源文件的SHT在源文件中对该section进行定位，并结合这个符号的符号表表项中的“在section中的offest”与“自身所占的size”这两个信息，定位出这个符号在对应的section中的具体的区域，这样我们就会得到这个符号的数据，随即将之写入目标文件的`buffer`，并且将这个符号在目标文件的新section中的offset和其他信息写入目标文件新创建的符号表中对应的表项

下面分析代码

![](https://tva1.sinaimg.cn/large/008i3skNly1gwrniuodndj30ty0bgq4u.jpg)

首先是在执行完前面实现的`compute_section_header`函数之后，为目标文件的符号表分配内存，并且设置好符号表的长度(即符号的个数，和`smap_table`数组所包含的元素的个数相等)，之后调用`merge_section`函数，接下来分析`merge_section`函数

![](https://tva1.sinaimg.cn/large/008i3skNly1gwrnm5dpmvj30u208sjsw.jpg)

函数一开始定义了几个变量，`line_written`用于记录“写到了目标文件的`buffer`的第几行”，`symt_written`用于记录“写到了目标文件的符号表的第几行”，`sym_section_offset`用于记录“写到了对应section的第几行”，这在填写目标文件的符号表时有用

整个函数的代码如下，总的逻辑就是"*merge by the dst.sht order in symbol unit*"，我们每次合并出目标文件的一个section，在合并出这个section的过程中，先遍历每个源文件，在它对应的循环的内部遍历它的符号表，如果发现在`smap_table`中有`smap_t`的`src`指向当前被遍历到的符号，就对其按照前面我们前面介绍的定位符号对应的数据的方式，定位到需要参与section合并的数据，然后进行合并的操作，结合代码的注释还有前面的介绍应该很好理解：

```c
// precondition: dst should know the section offset of each section
// merge the target section lines from ELF files and update dst symtab
static void merge_section(elf_t **srcs, int num_srcs, elf_t *dst,
    smap_t *smap_table, int *smap_count)
{
    int line_written = 1 + 1 + dst->sht_count;
    int symt_written = 0;
    int sym_section_offset = 0;

    for (int section_index = 0; section_index < dst->sht_count; ++ section_index)
    {
        // merge by the dst.sht order in symbol unit

        // get the section by section id
        sh_entry_t *target_sh = &dst->sht[section_index];
        sym_section_offset = 0;
        debug_printf(DEBUG_LINKER, "merging section '%s'\n", target_sh->sh_name);

        // merge the sections
        // scan every input ELF file
        for (int i = 0; i < num_srcs; ++ i)
        {
            debug_printf(DEBUG_LINKER, "\tfrom source elf [%d]\n", i);
            int src_section_index = -1;
            // scan every section in this elf
            for (int j = 0; j < srcs[i]->sht_count; ++ j)
            {
                // check if this ELF srcs[i] contains the same section as target_sh
                if (strcmp(target_sh->sh_name, srcs[i]->sht[j].sh_name) == 0)
                {
                    // we have found the same section name
                    src_section_index = j;
                    // break;
                }
            }

            // check if we have found this target section from src ELF
            if (src_section_index == -1)
            {
                // search for the next ELF
                // because the current ELF srcs[i] does not contain the target_sh
                continue;
            }
            else
            {
                // found the section in this ELF srcs[i]
                // check its symtab
                for (int j = 0; j < srcs[i]->symt_count; ++ j)
                {
                    st_entry_t *sym = &srcs[i]->symt[j];

                    if (strcmp(sym->st_shndx, target_sh->sh_name) == 0)
                    {
                        for (int k = 0; k < *smap_count; ++ k)
                        {
                            // scan the cached dst symbols to check
                            // if this symbol should be merged into this section
                            if (sym == smap_table[k].src)
                            {
                                // exactly the cached symbol
                                debug_printf(DEBUG_LINKER, "\t\tsymbol '%s'\n", sym->st_name);

                                // this symbol should be merged into dst's section target_sh
                                // copy this symbol from srcs[i].buffer into dst.buffer
                                // srcs[i].buffer[sh_offset + st_value, sh_offset + st_value + st_size] inclusive
                                for (int t = 0; t < sym->st_size; ++ t)
                                {
                                    int dst_index = line_written + t;
                                    int src_index = srcs[i]->sht[src_section_index].sh_offset +
                                        sym->st_value + t;
                                    
                                    assert(dst_index < MAX_ELF_FILE_LENGTH);
                                    assert(src_index < MAX_ELF_FILE_LENGTH);
                                    
                                    strcpy(
                                        dst->buffer[dst_index],
                                        srcs[i]->buffer[src_index]);
                                }

                                // copy the symbol table entry from srcs[i].symt[j] to
                                // dst.symt[symt_written]
                                assert(symt_written < dst->symt_count);
                                // copy the entry
                                strcpy(dst->symt[symt_written].st_name, sym->st_name);
                                dst->symt[symt_written].bind = sym->bind;
                                dst->symt[symt_written].type = sym->type;
                                strcpy(dst->symt[symt_written].st_shndx, sym->st_shndx);
                                // MUST NOT BE A COMMON, so the section offset MUST NOT BE alignment
                                dst->symt[symt_written].st_value = sym_section_offset;
                                dst->symt[symt_written].st_size = sym->st_size;

                                // update the smap_table
                                // this will hep the relocation
                                smap_table[k].dst = &dst->symt[symt_written];

                                // udpate the counter
                                symt_written += 1;
                                line_written += sym->st_size;
                                sym_section_offset += sym->st_size;
                            }
                        }
                        // symbol srcs[i].symt[j] has been checked
                    }
                }
                // all symbols in ELF file srcs[i] has been checked
            }
        }
        // dst.sht[section_index] has been merged from src ELFs
    }
    // all .text, .rodata, .data sections in dst has been merged

    // finally, merge .symtab
    for (int i = 0; i < dst->symt_count; ++ i)
    {
        st_entry_t *sym = &dst->symt[i];
        sprintf(dst->buffer[line_written], "%s,%s,%s,%s,%ld,%ld", 
            sym->st_name, get_stb_string(sym->bind), get_stt_string(sym->type),
            sym->st_shndx, sym->st_value, sym->st_size);
        line_written ++;
    }
    assert(line_written == dst->line_count);
}
```

还可以看到，在函数的后面，每填写完目标文件的符号表的一个表项时，也会将对应的`smap_t`中的`dst`初始化为刚刚写好的表项，这将为我们下一步的重定位打下基础

Reference:

https://ivanzz1001.github.io/records/post/cplusplus/2018/11/12/cpluscplus-segment

https://www.bilibili.com/video/BV1Lh411D7fh?spm_id_from=333.999.0.0

https://github.com/yangminz/bcst_csapp/tree/d2c4f611d0cffb8e029c254a41100be58392577f