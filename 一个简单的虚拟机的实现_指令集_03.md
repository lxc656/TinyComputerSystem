//本篇blog代码参考自https://github.com/yangminz/bcst_csapp/tree/31eeb74aa3489a3f9fac02b9c65b202f6a13ee55

# 关于规约(Reduce)

​		首先介绍一下规约(reduce)的概念，从物理学的角度来看，这个世界的发展变化是一个不断熵增的过程，事物逐渐变得更加复杂，并且难以还原回之前的状态，在计算机中，函数调用对cpu和memory这些计算机资源进行了规约，它利用cpu的计算资源和内存的数据，完成了计算，但我们很难通过计算得到的结果还原回计算机在计算最开始的状态，在数据结构中，以树为例，先后遍历过一个节点的左右子树之后，这个节点连同它的左右子树被规约成了一个节点，我们也无法仅仅通过这个规约后得到的节点还原回原来的左右子树。遍历其中的一个子树的过程可以被理解为先进入子树最后离开子树，就像入栈和出栈。因此规约的过程可以用入/出栈来完成，表达式向它最终的计算结果的转化就是一个用入/出栈来不断规约的过程，计算表达式时，可以维护两个栈，把从左到右依次遇到的数放入第一个栈中，把从左到右遇到的运算符放入第二个栈中，如果第一个栈顶部有两个数的同时，第二个栈顶部有一个运算符，那就对这两个数进行运算符对应的运算，得出运算结果，之后把刚才运算中的两个数和一个运算符从栈中弹出，把运算结果放入第一个栈中(e.g. 第一个栈顶部有7和8，第二个栈顶部有+，那么最后+,7,8都被弹出了栈，15被压入了存放数据的栈)，从而完成了对参与运算的两个数和一个运算符这三个元素的规约，这样如此往复可以完成对表达式的计算(这也是逆波兰表达式计算的思路)，把表达式理解为规约也可以解释为什么不能在C语言里把0<x&&x<9写成0<x<9，因为如果这样做的话，编译器会先对0<x规约，得出结果是0/1，之后拿这个结果和<运算符和9再进行规约，这个计算的逻辑完全不是我们想要的

​		如果我们想通过规约后得到的结果回到最初的状态，只能在规约时“构造一台时间机器”，也就是要额外记录很多信息(在每个时间节点都干了什么)，从物理学的角度来讲，就是要额外耗费很多能量，因此这更可以说明，计算机和现实世界都是在不断的进行规约，不断的走向熵增

# 让虚拟机支持push指令

​		正是因为规约的过程可以通过入/出栈来实现，而函数调用又是对计算机资源的规约，因此C语言的函数调用通过栈来实现，我们接下来实现虚拟机中将寄存器中的值压入栈(简称为将寄存器压入栈)的push指令的硬件功能的模拟，代码如下：

```c
void push_reg_handler(uint64_t src, uint64_t dst)
{
    // src: reg
    // dst: empty
    reg.rsp = reg.rsp - 0x8;
    write64bits_dram(va2pa(reg.rsp),*(uint64_t *)src);
    reg.rip = reg.rip + sizeof(inst_t);
}
```

此外，对于把寄存器中的值存入内存的指令，对支持它的硬件的模拟如下

```c
void mov_reg_mem_handler(uint64_t src, uint64_t dst)
{
    // src: reg
    // dst: mem virutal address
    write64bits_dram(va2pa(dst),*(uint64_t *)src);
		reg.rip = reg.rip + sizeof(inst_t);
}
```

