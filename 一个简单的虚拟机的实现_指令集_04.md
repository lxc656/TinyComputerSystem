为了让虚拟机实现更多的功能，更接近真实的CPU，比如说拥有SF,ZF,OF这种标志位，以及模拟多核CPU，更自然的直接处理字符串类型的汇编指令而非人为刻意构造的struct类型的指令，因此进行了代码重构，重构后的文件结构如下

```shell
.
├── countlines.sh
├── makefile
├── README.md
└── src
    ├── common
    │   ├── convert.c
    │   └── print.c
    ├── hardware
    │   ├── cpu
    │   │   ├── isa.c
    │   │   └── mmu.c
    │   └── memory
    │       └── dram.c
    ├── headers
    │   ├── common.h
    │   ├── cpu.h
    │   └── memory.h
    └── main_hardware.c
```

# DFA解析立即数

我们在convert.c中使用有限自动机(DFA，deterministic finite automata)对汇编指令操作数中的字符串形式的立即数进行解析，将其转换成整数

有限自动机的逻辑大致如下图所示(实际的代码实现中多了对输入中带有空格的判断)，根据输入的字符，决定它跳转到哪个状态，完成跳转之后继续接受输入，循环往复，时间复杂度是线性的O(n)

![](https://tva1.sinaimg.cn/large/008i3skNly1gw010zt3vvj315e0ew3zl.jpg)

代码实现如下：

```c
uint64_t string2uint_range(const char *str, int start, int end)
{
    // start: starting index inclusive
    // end: ending index includsive
    end = (end == -1) ? strlen(str) - 1 : end;

    uint64_t uv = 0;
    int sign_bit = 0; // 0 - positive; 1 - negative

    // DFA: deterministic finite automata to scan string and get value
    int state = 0;
    
    for (int i = start; i <= end; ++ i)
    {
        char c = str[i];

        if (state == 0)
        {
            if (c == '0')
            {
                state = 1;
                uv = 0;
                continue;
            }
            else if ('1' <= c && c <= '9')
            {
                state = 2;
                uv = c - '0';
                continue;
            }
            else if (c == '-')
            {
                state = 3;
                sign_bit = 1;
                continue;
            }
            else if (c == ' ')
            {
                state = 0;
                continue;
            }
            else { goto fail; }
        }
        else if (state == 1)
        {
            if ('0' <= c && c <= '9')
            {
                state = 2;
                uv = uv * 10 + c - '0';
                continue;
            }
            else if (c == 'x')
            {
                state = 4;
                continue;
            }
            else if (c == ' ')
            {
                state = 6;
                continue;
            }
            else { goto fail; }
        }
        else if (state == 2)
        {
            if ('0' <= c && c <= '9')
            {
                state = 2;
                uint64_t pv = uv;
                uv = uv * 10 + c - '0';
                // maybe overflow
                if (pv > uv)
                {
                    printf("(uint64_t)%s overflow: cannot convert\n", str);
                    goto fail;
                }
                continue;
            }
            else if (c == ' ')
            {
                state = 6;
                continue;
            }
            else { goto fail; }
        }
        else if (state == 3)
        {
            if (c == '0')
            {
                state = 1;
                continue;
            }
            else if ('1' <= c && c <= '9')
            {
                state = 2;
                uv = c - '0';
                continue;
            }
            else { goto fail; }
        }
        else if (state == 4)
        {
            if ('0' <= c && c <= '9')
            {
                state = 5;
                uv = uv * 16 + c - '0';
                continue;
            }
            else if ('a' <= c && c <= 'f')
            {
                state = 5;
                uv = uv * 16 + c - 'a' + 10;
                continue;
            }
            else { goto fail; }
        }
        else if (state == 5)
        {
            // hex
            if ('0' <= c && c <= '9')
            {
                state = 5;
                uint64_t pv = uv;
                uv = uv * 16 + c - '0';
                // maybe overflow
                if (pv > uv)
                {
                    printf("(uint64_t)%s overflow: cannot convert\n", str);
                    goto fail;
                }
                continue;
            }
            else if ('a' <= c && c <= 'f')
            {
                state = 5;
                uint64_t pv = uv;
                uv = uv * 16 + c - 'a' + 10;
                // maybe overflow
                if (pv > uv)
                {
                    printf("(uint64_t)%s overflow: cannot convert\n", str);
                    goto fail;
                }
                continue;
            }
            else { goto fail; }
        }
        else if (state == 6)
        {
            if (c == ' ')
            {
                state = 6;
                continue;
            }
            else { goto fail; }
        }
    }

    if (sign_bit == 0)
    {
        return uv;
    }
    else if (sign_bit == 1)
    {
        if ((uv & 0x8000000000000000) != 0)
        {
            printf("(int64_t)%s: signed overflow: cannot convert\n", str);
            exit(0);
        }
        int64_t sv = -1 * (int64_t)uv;
        return *((uint64_t *)&sv);
    }

    fail:
    printf("type converter: <%s> cannot be converted to integer\n", str);
    exit(0);
}

```

# CPU的标志位

使用如下的union的数据结构来模拟CPU标志位

```c
typedef struct CPU_FLAGS_STRUCT
{
    union
    {
        uint64_t __cpu_flag_value;
        struct
        {    
            // carry flag: detect overflow for unsigned operations
            uint16_t CF;
            // zero flag: result is zero
            uint16_t ZF;
            // sign flag: result is negative: highest bit
            uint16_t SF;
            // overflow flag: detect overflow for signed operations
            uint16_t OF;
        };
    };
} cpu_flag_t;
```

因为是union，所以可以通过操作__cpu_flag_value来一次性为四个标志位赋值，这样的设计会便于我们后续的操作

# 解析汇编操作数

接下来完成对于除了立即数以外的汇编操作数的解析，首先是寄存器操作数，其中首先在isa.c的parse_operand函数这样一个解析操作数的大的框架中进行如下判断(在这个else if前面的判断语句是通过' $ '判断操作数是否是立即数然后跳转到上面我们实现的函数)，之后转到reflect_register函数去做真正的解析

```c
else if (str[0] == '%')
{
	// register
	od->type = REG;
	od->reg1 = reflect_register(str, cr);
	return;
}
```

btw , parse_operand函数的原型如下：

```c
static void parse_operand(const char *str, od_t *od, core_t *cr);
```

它的作用就是将字符串形式的指令中的字符串形式的操作数转换成我们之前用结构体形式存储的操作数，然后调用我们之前实现的handler，完成指令的功能，并且有一个参数是指定所使用的CPU核，此处的core_t类型其实就是我们之前实现的struct类型的cpu_t，我们在此处通过创建多个这样的对象从而模拟多核CPU，尤其是在接下来实现的解析寄存器操作数中，每个CPU核的寄存器的值都不一样，因此必须要指定是哪个核的寄存器

接下来实现解析寄存器操作数的reflect_register函数，我们虚拟机每次运行的时候，各个core_t类型的模拟CPU核在内存中的地址是不固定的，因此每个core_t类型的结构体中的用来模拟寄存器的整数型变量的地址也是不一样的，我们要做的，是把描述使用哪个寄存器的字符串(比如"rax")先映射成一个在core_t结构体里的index(整数类型的索引)，然后根据这个index去索引得到用来模拟寄存器的整数类型的变量在内存中的地址，然后把地址存入指令结构体，然后handler根据指令结构体中保存的地址，从而修改寄存器的值以及完成寄存器相关的操作

下面这个字符串数组里面记录了所有寄存器的名字，我们接下来就会通过它得到某个特定寄存器的index

```c
// lookup table
static const char *reg_name_list[72] = {
    "%rax","%eax","%ax","%ah","%al",
    "%rbx","%ebx","%bx","%bh","%bl",
    "%rcx","%ecx","%cx","%ch","%cl",
    "%rdx","%edx","%dx","%dh","%dl",
    "%rsi","%esi","%si","%sih","%sil",
    "%rdi","%edi","%di","%dih","%dil",
    "%rbp","%ebp","%bp","%bph","%bpl",
    "%rsp","%esp","%sp","%sph","%spl",
    "%r8","%r8d","%r8w","%r8b",
    "%r9","%r9d","%r9w","%r9b",
    "%r10","%r10d","%r10w","%r10b",
    "%r11","%r11d","%r11w","%r11b",
    "%r12","%r12d","%r12w","%r12b",
    "%r13","%r13d","%r13w","%r13b",
    "%r14","%r14d","%r14w","%r14b",
    "%r15","%r15d","%r15w","%r15b",
};
```

得到index的方法大概就是遍历上面这个lookup table，这会在接下来的代码里看到具体实现

然后我们再用一个table存储这些用于模拟寄存器的整数型变量的地址，如下：

```c
uint64_t reg_addr[72] = {
        (uint64_t)&(reg->rax),(uint64_t)&(reg->eax),(uint64_t)&(reg->ax),(uint64_t)&(reg->ah),(uint64_t)&(reg->al),
        (uint64_t)&(reg->rbx),(uint64_t)&(reg->ebx),(uint64_t)&(reg->bx),(uint64_t)&(reg->bh),(uint64_t)&(reg->bl),
        (uint64_t)&(reg->rcx),(uint64_t)&(reg->ecx),(uint64_t)&(reg->cx),(uint64_t)&(reg->ch),(uint64_t)&(reg->cl),
        (uint64_t)&(reg->rdx),(uint64_t)&(reg->edx),(uint64_t)&(reg->dx),(uint64_t)&(reg->dh),(uint64_t)&(reg->dl),
        (uint64_t)&(reg->rsi),(uint64_t)&(reg->esi),(uint64_t)&(reg->si),(uint64_t)&(reg->sih),(uint64_t)&(reg->sil),
        (uint64_t)&(reg->rdi),(uint64_t)&(reg->edi),(uint64_t)&(reg->di),(uint64_t)&(reg->dih),(uint64_t)&(reg->dil),
        (uint64_t)&(reg->rbp),(uint64_t)&(reg->ebp),(uint64_t)&(reg->bp),(uint64_t)&(reg->bph),(uint64_t)&(reg->bpl),
        (uint64_t)&(reg->rsp),(uint64_t)&(reg->esp),(uint64_t)&(reg->sp),(uint64_t)&(reg->sph),(uint64_t)&(reg->spl),
        (uint64_t)&(reg->r8),(uint64_t)&(reg->r8d),(uint64_t)&(reg->r8w),(uint64_t)&(reg->r8b),
        (uint64_t)&(reg->r9),(uint64_t)&(reg->r9d),(uint64_t)&(reg->r9w),(uint64_t)&(reg->r9b),
        (uint64_t)&(reg->r10),(uint64_t)&(reg->r10d),(uint64_t)&(reg->r10w),(uint64_t)&(reg->r10b),
        (uint64_t)&(reg->r11),(uint64_t)&(reg->r11d),(uint64_t)&(reg->r11w),(uint64_t)&(reg->r11b),
        (uint64_t)&(reg->r12),(uint64_t)&(reg->r12d),(uint64_t)&(reg->r12w),(uint64_t)&(reg->r12b),
        (uint64_t)&(reg->r13),(uint64_t)&(reg->r13d),(uint64_t)&(reg->r13w),(uint64_t)&(reg->r13b),
        (uint64_t)&(reg->r14),(uint64_t)&(reg->r14d),(uint64_t)&(reg->r14w),(uint64_t)&(reg->r14b),
        (uint64_t)&(reg->r15),(uint64_t)&(reg->r15d),(uint64_t)&(reg->r15w),(uint64_t)&(reg->r15b),
    };
```

而且这个table必须要在reflect_register这个函数内部声明，因为上面说过了，每个用于模拟CPU核的结构体的地址在每次程序运行时都不同，因此不可以在函数体外把这个table声明为静态的全局变量

reflect_register函数的完整实现如下：

```c
static uint64_t reflect_register(const char *str, core_t *cr)
{    
    // lookup table
    reg_t *reg = &(cr->reg);
    uint64_t reg_addr[72] = {
        (uint64_t)&(reg->rax),(uint64_t)&(reg->eax),(uint64_t)&(reg->ax),(uint64_t)&(reg->ah),(uint64_t)&(reg->al),
        (uint64_t)&(reg->rbx),(uint64_t)&(reg->ebx),(uint64_t)&(reg->bx),(uint64_t)&(reg->bh),(uint64_t)&(reg->bl),
        (uint64_t)&(reg->rcx),(uint64_t)&(reg->ecx),(uint64_t)&(reg->cx),(uint64_t)&(reg->ch),(uint64_t)&(reg->cl),
        (uint64_t)&(reg->rdx),(uint64_t)&(reg->edx),(uint64_t)&(reg->dx),(uint64_t)&(reg->dh),(uint64_t)&(reg->dl),
        (uint64_t)&(reg->rsi),(uint64_t)&(reg->esi),(uint64_t)&(reg->si),(uint64_t)&(reg->sih),(uint64_t)&(reg->sil),
        (uint64_t)&(reg->rdi),(uint64_t)&(reg->edi),(uint64_t)&(reg->di),(uint64_t)&(reg->dih),(uint64_t)&(reg->dil),
        (uint64_t)&(reg->rbp),(uint64_t)&(reg->ebp),(uint64_t)&(reg->bp),(uint64_t)&(reg->bph),(uint64_t)&(reg->bpl),
        (uint64_t)&(reg->rsp),(uint64_t)&(reg->esp),(uint64_t)&(reg->sp),(uint64_t)&(reg->sph),(uint64_t)&(reg->spl),
        (uint64_t)&(reg->r8),(uint64_t)&(reg->r8d),(uint64_t)&(reg->r8w),(uint64_t)&(reg->r8b),
        (uint64_t)&(reg->r9),(uint64_t)&(reg->r9d),(uint64_t)&(reg->r9w),(uint64_t)&(reg->r9b),
        (uint64_t)&(reg->r10),(uint64_t)&(reg->r10d),(uint64_t)&(reg->r10w),(uint64_t)&(reg->r10b),
        (uint64_t)&(reg->r11),(uint64_t)&(reg->r11d),(uint64_t)&(reg->r11w),(uint64_t)&(reg->r11b),
        (uint64_t)&(reg->r12),(uint64_t)&(reg->r12d),(uint64_t)&(reg->r12w),(uint64_t)&(reg->r12b),
        (uint64_t)&(reg->r13),(uint64_t)&(reg->r13d),(uint64_t)&(reg->r13w),(uint64_t)&(reg->r13b),
        (uint64_t)&(reg->r14),(uint64_t)&(reg->r14d),(uint64_t)&(reg->r14w),(uint64_t)&(reg->r14b),
        (uint64_t)&(reg->r15),(uint64_t)&(reg->r15d),(uint64_t)&(reg->r15w),(uint64_t)&(reg->r15b),
    };
    for (int i = 0; i < 72; ++ i)
    {
        if (strcmp(str, reg_name_list[i]) == 0)
        {
            // now we know that i is the index inside reg_name_list
            return reg_addr[i];
        }
    }
    printf("parse register %s error\n", str);
    exit(0);
}
```

接下来要解析的操作数类型只剩memory access类和非法操作数

memory access类的操作数的文法的范式如下

*Imm*(rb , ri , s)

我们采用除了DFA以外的一种解析策略，这种方法简单的说就是计数(counting)，我们使用两个变量分别记录被解析的表达式目前解析出了几个','以及'('和')'，通过记录扫描到的括号和逗号的数目(在下面的代码里用ca记录扫描到了几个括号，左括号和右括号都算，用cb来记录扫描到了几个逗号)，从而在汇编操作数表达式的文法的约束下判断目前的解析状态，表达式中每个不同的组成部分在被解析到时对应的ca和cb的值都不一样，因此我们通过对ca和cb的值进行条件判断，从而将表达式的不同部分拆分出来，也就是将表达式的立即数部分对应的字符串拆分到一个字符串缓冲区里，将表达式的两个寄存器部分对应的字符串拆分到另外两个字符串缓冲区里，将表达式的scal部分也进行类似的拆分，然后依据各种memory access指令各自的文法(参考下图)，判定出当前这条指令的具体类型

![](https://tva1.sinaimg.cn/large/008i3skNly1gw8xoklw62j30v40agtaf.jpg)

并且使用前面实现的解析字符串和立即数的函数，最终就完成了对整条指令的解析，详见如下代码

```c
 else
    {
        // memory access
        char imm[64] = {'\0'};
        int imm_len = 0;
        char reg1[64] = {'\0'};
        int reg1_len = 0;
        char reg2[64] = {'\0'};
        int reg2_len = 0;
        char scal[64] = {'\0'};
        int scal_len = 0;

        int ca = 0; // ()
        int cb = 0; // comma ,

        for (int i = 0; i < str_len; ++ i)
        {
            char c = str[i];

            if (c == '(' || c == ')')
            {
                ca ++;
                continue;
            }
            else if (c == ',')
            {
                cb ++;
                continue;
            }
            else 
            {
                // parse imm(reg1,reg2,scal)
                if (ca == 0)
                {
                    // xxx
                    imm[imm_len] = c;
                    imm_len ++;
                    continue;
                }
                else if (ca == 1)
                {
                    if (cb == 0)
                    {
                        // ???(xxxx
                        // (xxxx
                        reg1[reg1_len] = c;
                        reg1_len ++;
                        continue;
                    }
                    else if (cb == 1)
                    {
                        // (???,xxxxx
                        // ???(???,xxxxx
                        // (,xxxxx
                        // ???(,xxxxx
                        reg2[reg2_len] = c;
                        reg2_len ++;
                        continue;
                    }
                    else if (cb == 2)
                    {
                        // (???,???,xxxxx
                        scal[scal_len] = c;
                        scal_len ++;
                    }
                }
            }
        }

        // imm, reg1, reg2, scal

        if (imm_len > 0)
        {
            od->imm = string2uint(imm);
            if (ca == 0)
            {
                // imm
                od->type = MEM_IMM;
                return;
            }
        }

        if (scal_len > 0)
        {
            od->scal = string2uint(scal);
            if (od->scal != 1 && od->scal != 2 && od->scal != 4  && od->scal != 8)
            {
                printf("%s is not a legal scaler\n", scal);
                exit(0);
            }
        }

        if (reg1_len > 0)
        {
            od->reg1 = reflect_register(reg1, cr);
        }

        if (reg2_len > 0)
        {
            od->reg2 = reflect_register(reg2, cr);
        }

        // set operand type
        if (cb == 0)
        {
            if (imm_len > 0)
            {
                od->type = MEM_IMM_REG1;
                return;
            }
            else 
            {
                od->type = MEM_REG1;
                return;
            }
        }
        else if (cb == 1)
        {
            if (imm_len > 0)
            {
                od->type = MEM_IMM_REG1_REG2;
                return;
            }
            else 
            {
                od->type = MEM_REG1_REG2;
                return;
            }
        }
        else if (cb == 2)
        {
            if (reg1_len > 0)
            {
                // reg1 exists
                if (imm_len > 0)
                {
                    od->type = MEM_IMM_REG1_REG2_SCAL;
                    return;
                }
                else 
                {
                    od->type = MEM_REG1_REG2_SCAL;
                    return;
                }
            }
            else
            {
                // no reg1
                if (imm_len > 0)
                {
                    od->type = MEM_IMM_REG2_SCAL;
                    return;
                }
                else 
                {
                    od->type = MEM_REG2_SCAL;
                    return;
                }
            }            
        }
    }
}
```

Reference:

https://github.com/yangminz/bcst_csapp/

