在上一篇Blog读取ELF和过滤完注释信息后，接下来实现对节头表和符号表的解析，同样是在`linker/ParseElf.c`中实现相应的函数，首先介绍`parse_table_entry`函数

这个函数的参数有一些特殊，需要额外说明

```c
static int parse_table_entry(char *str, char ***ent);
```

其中参数ent是三级指针，对于这个三级指针的解读如下：

ent这个变量的值是一个栈中空间的地址，也就是说ent指向栈中存放的一个64位变量，这个变量是一个指针，指向堆中的空间，堆中对应的空间里存放的也是一个64位长的指针变量，而且指向一个字符串，因此提领(此处是候捷老师讲授C++时使用的术语，意为取指针类型变量x指向的值，即取*x)3次之后就会得到对应的字符串，这3次提领的过程如下图所示

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwovfx20zdj31720u0777.jpg" style="zoom:50%;" />

我们结合函数体中的具体实现来分析；

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwovl81ijhj30p20j8gnn.jpg" style="zoom:50%;" />

我们要解析的txt文件中的符号表/节头表的表项都是以字符串形式展现的，对应`parse_table_entry`函数的参数`str`，上图代码的13~23行时将`str`指向的字符串表项按照","的分隔划分成一个又一个的列，即查出来每个表项有几个元素，使用`count_col`变量来记录，之后在代码的25行给当前表项的每个元素都在堆里申请一段内存，用于在将来作为缓冲区存放这个元素，此处的二级指针arr因为是函数内的局部变量所以在栈中存放，提领一次后可以得到存放在堆中的字符串指针，提领两次后可以得到缓冲区中的字符串，而三级指针`ent`指向`arr`，这些都和上面对于三级指针`ent`的解读相符

之后继续分析这个函数剩下的代码

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwox7pko54j30sk0v6q6j.jpg" style="zoom:50%;" />

做的事情就是把一个字符串形式的表项依照","的分隔解析成一个个元素，然后将每个元素存入一个在堆中新申请的字符串，把这个字符串的地址放入前面介绍过的同样位于堆中的arr数组中

因为解析表项的函数使用了malloc动态申请堆中的内存，就还需要一个函数来在解析表项的工作结束后将malloc动态申请的内存释放，以免内存泄漏：

```c
static void free_table_entry(char **ent, int n)
{
    for (int i = 0; i < n; ++ i)
    {
        free(ent[i]);
    }
    free(ent);
}
```

作为参数的二级指针ent指向堆中的空间，将堆中存储的字符串指针指向的字符串所在的堆空间释放掉，之后再将ent指向的存储字符串指针的堆空间释放掉，释放了我们之前申请的全部堆内存

将这两个函数结合起来就可以处理各种表项

我们接下来使用这样一个解析表项的方法去解析Section Header

```c
static void parse_sh(char *str, sh_entry_t *sh)
{
    // .text,0x0,4,22
    char **cols;
    int num_cols = parse_table_entry(str, &cols);
    assert(num_cols == 4);

    assert(sh != NULL);
    strcpy(sh->sh_name, cols[0]);
    sh->sh_addr = string2uint(cols[1]);
    sh->sh_offset = string2uint(cols[2]);
    sh->sh_size = string2uint(cols[3]);

    free_table_entry(cols, num_cols);
}
```

三级指针`&cols`作为参数被传递给`parse_table_entry`，从而使得`&cols`指向的二级指针`cols`的值就是堆空间中字符串指针数组的首地址(也就是以传指针的方式传参)，字符串指针数组中的每个指针都指向堆中存放表项元素的字符串

上面的解析Section Header的函数可以做到将一个字符串形式的Section Header中的信息提取到一个`sh_entry_t`类型的结构体中，最后通过调用`free_table_entry`将解析的过程中申请的堆中的缓冲区释放

解析符号表的实现如下

```c
static void parse_symtab(char *str, st_entry_t *ste)
{
    // sum,STB_GLOBAL,STT_FUNCTION,.text,0,22
    char **cols;
    int num_cols = parse_table_entry(str, &cols);
    assert(num_cols == 6);

    assert(ste != NULL);
    strcpy(ste->st_name, cols[0]);

    // select symbol bind
    if (strcmp(cols[1], "STB_LOCAL") == 0)
    {
        ste->bind = STB_LOCAL;
    }
    else if (strcmp(cols[1], "STB_GLOBAL") == 0)
    {
        ste->bind = STB_GLOBAL;
    }
    else if (strcmp(cols[1], "STB_WEAK") == 0)
    {
        ste->bind = STB_WEAK;
    }
    else
    {
        printf("symbol bind is neiter LOCAL, GLOBAL, nor WEAK\n");
        exit(0);
    }
    
    // select symbol type 
    if (strcmp(cols[2], "STT_NOTYPE") == 0)
    {
        ste->type = STT_NOTYPE;
    }
    else if (strcmp(cols[2], "STT_OBJECT") == 0)
    {
        ste->type = STT_OBJECT;
    }
    else if (strcmp(cols[2], "STT_FUNC") == 0)
    {
        ste->type = STT_FUNC;
    }
    else
    {
        printf("symbol type is neiter NOTYPE, OBJECT, nor FUNC\n");
        exit(0);
    }

    strcpy(ste->st_shndx, cols[3]);

    ste->st_value = string2uint(cols[4]);
    ste->st_size = string2uint(cols[5]);

    free_table_entry(cols, num_cols);
}
```

最终还要向外界暴露两个非静态的函数，便是下面的`parse_elf`和`free_elf`

```c
void parse_elf(char *filename, elf_t *elf)
{
    assert(elf != NULL);
    int line_count = read_elf(filename, (uint64_t)(&(elf->buffer)));
    for (int i = 0; i < line_count; ++ i)
    {
        printf("[%d]\t%s\n", i, elf->buffer[i]);
    }

    // parse section headers
    int sh_count = string2uint(elf->buffer[1]);
    elf->sht = malloc(sh_count * sizeof(sh_entry_t));

    sh_entry_t *symt_sh = NULL;
    for (int i = 0; i < sh_count; ++ i)
    {
        parse_sh(elf->buffer[2 + i], &(elf->sht[i]));
        print_sh_entry(&(elf->sht[i]));

        if (strcmp(elf->sht[i].sh_name, ".symtab") == 0)
        {
            // this is the section header for symbol table
            symt_sh = &(elf->sht[i]);
        }
    }

    assert(symt_sh != NULL);

    // parse symbol table
    elf->symt_count = symt_sh->sh_size;
    elf->symt = malloc(elf->symt_count * sizeof(st_entry_t));
    for (int i = 0; i < symt_sh->sh_size; ++ i)
    {
        parse_symtab(
            elf->buffer[i + symt_sh->sh_offset],
            &(elf->symt[i]));
        print_symtab_entry(&(elf->symt[i]));
    }
}

void free_elf(elf_t *elf)
{
    assert(elf != NULL);

    free(elf->sht);
}
```

Reference:

https://github.com/yangminz/bcst_csapp/tree/7842d9c913ad48d233fc23384567e8df9bd715ee

https://www.bilibili.com/video/BV1Nz4y1279C?spm_id_from=333.999.0.0
