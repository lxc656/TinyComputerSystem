本篇Blog将继续完成静态链接器的实现以及介绍符号解析的三条规则，先前我们完成的工作可以理解为从硬盘中读取ELF文件然后将其解析并将有效信息写入内存中我们设计的`elf_t`的数据结构，接下来的工作是将若干个`elf_t`类型的数据合并为一个，这便是静态链接 

函数原型如下：

```c
void link_elf(elf_t **srcs, int num_srcs, elf_t *dst);
```

其中`srcs`的类型是`elf_t`指针数组，`dst`是指向`elf_t`类型的变量的指针，和上面说的“将若干个ELF合并为一个ELF”相对应，参数`num_srcs`是`elf_t`指针数组的元素个数，这个函数实现在`linker/staticlink.c`中，这也是该文件向外部暴露出的唯一的非静态函数，即唯一的对外接口

实现符号解析依赖于如下设计的一个关键数据结构

```c
// internal mapping between source and destination symbol entries
typedef struct
{
    elf_t       *elf;   // src elf file
    st_entry_t  *src;   // src symbol
    st_entry_t  *dst;   // dst symbol: used for relocation - find the function referencing the undefined symbol
    // TODO:
    // relocation entry (referencing section, referenced symbol) converted to (referencing symbol, referenced symbol) entry
} smap_t;
```

这个结构体有三个成员，两个符号表表项的指针和一个指向elf的指针

接下来简单介绍一下这个数据结构存在的意义

![](https://tva1.sinaimg.cn/large/008i3skNly1gwq93tm71cj31fu0pagp9.jpg)

如上图所示，在多个ELF源文件链接成一个目标文件的过程中，首先是进行符号解析：如果两个源文件中有相同的符号，只能选择其中一个映射到目标文件，在完成符号解析这样一个“去重”的过程之后，就要建立起源文件的符号和目标文件的符号的映射关系，如图中红色对号所在的边所示，上面的`smap_t`数据结构便是为了完成这样的映射的工作，`smap_t`的`src`指向源文件中的符号，`dst`指向目标文件中的符号，`elf`指向对应的源文件，因为有可能过个源文件中存在相同的符号，这样可以避免混淆

(在接下来的Blog中会实现链接步骤中的重定位，到时候还会在`smap_t`中加入用于重定位的指针变量)

下图的`link_elf`函数中的实现完成了符号解析的大致框架

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqapb0zj4j313w0cago1.jpg)

接下来介绍`symbol_processing`函数的实现，首先要遍历全部的源ELF文件，然后对每个ELF文件的符号表中的符号的Bind进行判断，首先完成对Bind为Local的判断

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqbkm9vajj310c0o4jvl.jpg)

在不同的源文件中如果出现了多个同名的符号，并且这些符号的Bind全是local，或者是这些符号中只有一个的Bind是global，其余全是local，都是合法的，最典型的例子就是在n个源文件中都存在`static int a=xxx`的定义，每个文件中的符号a的Bind都是local，因此这些源文件可以分别编译后链接在一起，但是在同一个ELF文件内，是不可以有同名的符号的

上述的代码的逻辑便是，如果当前的符号的Bind是local，那么就哪怕其他文件里有重名的符号也不会冲突，因此把这个符号直接加入到目标文件的符号表中(会在后续的代码里实现)，并在`smap_t`数组里记录好对应的符号映射关系

下面继续分析后面的代码

如果在遍历ELF文件的符号表的时候遇到了Bind为global而非local的符号(我们不考虑符号的Bind是weak的情况，因为这在工程中并不常见而且使用这种符号并不是一种被推荐的写法)，就有可能出现符号名冲突的情况，我们采用动态更新`smap_table`的方式来解决这个问题，当我们扫描到Bind为global的符号a时，先在已有的`smap_table`里寻找是否已经存在同名的且Bind也是global的符号a，如果有，那么就按照符号解析的原则去对`smap_table`进行更新，代码如下

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqd1bz2xej30x00u078t.jpg)

接下来我们实现符号解析，即上图中的`simple_resolution`函数

# 符号解析的3条规则

在CSAPP原书中有讲到符号解析的3条规则：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqdiccwj6j315208y75t.jpg)

CSAPP中提到了strong和weak的symbol，这和我们之前的global/weak Bind并不是相同的概念，这里的strong和weak可以被理解为符号的优先级，我们可以通过后面实现的`symbol_precedence`函数来对某个符号的优先级进行判定，如果这个符号是strong symbol(强符号)那么就返回2

我们依据此规则实现的`simple_resolution`函数如下

```c
static void simple_resolution(st_entry_t *sym, elf_t *sym_elf, smap_t *candidate)
{
    // sym: symbol from current elf file
    // candidate: pointer to the internal map table slot: src -> dst
    
    // determines which symbol is the one to be kept with 3 rules
    // rule 1: multiple strong symbols with the same name are not allowed
    // rule 2: given a strong symbol and multiple weak symbols with the same name, choose the strong symbol
    // rule 3: given multiple weak symbols with the same name, choose any of the weak symbols
    int pre1 = symbol_precedence(sym);
    int pre2 = symbol_precedence(candidate->src);

    if (pre1 == 2 && pre2 == 2)
    {
        /* rule 1
                pre1    pre2
            ---------------------
                2       2
         */
        debug_printf(DEBUG_LINKER, 
            "symbol resolution: strong symbol \"%s\" is redeclared\n", sym->st_name);
        exit(0);
    }
    else if (pre1 != 2 && pre2 != 2)
    {
        /* rule 3 - select higher precedence
                pre1    pre2
            ---------------------
                0       0
                0       1
                1       0
                1       1
         */
        // use the stronger one as best match
        if (pre1 > pre2)
        {
            // select sym as best match
            candidate->src = sym;
            candidate->elf = sym_elf;
        }
        return;
    }
    else if (pre1 == 2)
    {
        /* rule 2 - select current symbol
                pre1    pre2
            ---------------------
                2       0
                2       1
         */
        // select sym as best match
        candidate->src = sym;
        candidate->elf = sym_elf;
    }
    /* rule 2 - select candidate
            pre1    pre2
        ---------------------
            0       2
            1       2
    */
}
```

接下来实现判断符号优先程度的`symbol_precedence`函数，由于它的实现并不复杂，我们就把它设计成inline函数以提高效率

```c
static inline int symbol_precedence(st_entry_t *sym)
{
    // use inline function to imporve efficiency in run-time by preprocessing
    /*  we do not consider weak because it's very rare
        and we do not consider local because it's not conflicting

            bind        type        shndx               prec
            --------------------------------------------------
            global      notype      undef               0 - undefined
            global      object      common              1 - tentative
            global      object      data,bss,rodata     2 - defined
            global      func        text                2 - defined
    */
    assert(sym->bind == STB_GLOBAL);

    // get precedence of the symbol
    
    if (strcmp(sym->st_shndx, "SHN_UNDEF") == 0 && sym->type == STT_NOTYPE)
    {
        // Undefined: symbols referenced but not assigned a storage address
        return 0;
    }

    if (strcmp(sym->st_shndx, "COMMON") == 0 && sym->type == STT_OBJECT)
    {
        // Tentative: section to be decided after symbol resolution
        return 1;
    }

    if ((strcmp(sym->st_shndx, ".text") == 0 && sym->type == STT_FUNC) || 
        (strcmp(sym->st_shndx, ".data") == 0 && sym->type == STT_OBJECT) || 
        (strcmp(sym->st_shndx, ".rodata") == 0 && sym->type == STT_OBJECT) || 
        (strcmp(sym->st_shndx, ".bss") == 0 && sym->type == STT_OBJECT))
    {
        // Defined
        return 2;
    }

    debug_printf(DEBUG_LINKER, "symbol resolution: cannot determine the symbol \"%s\" precedence", sym->st_name);
    exit(0);
}
```

下面是对这个函数的解释，

在up主编写的文档中对符号的优先级的判断给出了准则：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqe4xr6b4j31aq06u0uk.jpg)

我们的简单链接器并不考虑weak bind的符号，对于一个函数来说，它在被声明的时候如果伴随着函数体，那么就是defined，否则就是undefined，对于变量来说，存在处于Tentative状态，即等待链接之后才能确定其是在.bss节还是.data节的可能(可参考之前关于符号的Type的判断的Bloghttps://zhuanlan.zhihu.com/p/434910876)，比如说在当前文件里是`int a;`这样的弱定义，在外部文件中出现了`int a=2;`这样的强定义，符号a对应的数据就会被存入.data节，如果外部没有强定义或者强定义是`int a=0;`，那么符号a对应的数据就会被存入.bss节，并且如果外部没有强定义的话`a`也会取默认值0，总结起来就是up主在这段代码的注释里的下面的这个图表，这个图表描述了符号的三元组到符号的优先级的映射关系

![](https://tva1.sinaimg.cn/large/008i3skNly1gwqf09unrgj30rc0a875b.jpg)

上面的函数实现便是这个映射关系的代码实现

我们这便完成了simple_resolution的实现，但真正的链接器在符号解析时除了要做simple_resolution以外，还要做complex_resolution和fatal_resolution，什么是complex_resolution呢？我们举一个例子来说明，在一个文件中有`int a=3`这样的对`a`的定义，在另一个文件中有`long long a=2147483648 `这样对`a`的定义，链接之后生成的目标文件中，符号a对应的数据的size是4字节，而不是`long long`类型的长度—8字节，像这样的被链接的两个ELF文件中变量`a`的size不一样的情况下进行的符号解析，就是complex_resolution，在这里complex_resolution选择让a的size取两者之中的较小值，这就是对complex_resolution的一个简单的解释。对于什么是fatal_resolution，可以用下面的例子来说明，如果我们在一个文件里将变量`a`定义为整数类型，在另一个文件里`a`是一个函数的名字，编译后链接在一起，就会发生类似下面这样的报错

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqjiv5j7lj30w606odgu.jpg" style="zoom:40%;" />

错误的原因很明显，两个文件的符号a的三元组的Type信息不一样，一个是object，一个是function，因为这样的冲突无法处理，所以就进行fatal_resolution，正如其名fatal

Reference:

https://www.bilibili.com/video/BV1EZ4y1A7qM?spm_id_from=333.999.0.0

https://github.com/yangminz/bcst_csapp/tree/32dff6910b379436bef854252ca0dae4a06200ed